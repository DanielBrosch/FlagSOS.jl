<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · FlagSOS.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://DanielBrosch.github.io/FlagSOS.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>FlagSOS.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/TriangleFreeGraphs/">Basic example: Mantel&#39;s theorem</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="FlagSOS"><a class="docs-heading-anchor" href="#FlagSOS">FlagSOS</a><a id="FlagSOS-1"></a><a class="docs-heading-anchor-permalink" href="#FlagSOS" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/DanielBrosch/FlagSOS.jl">FlagSOS</a>.</p><ul><li><a href="#FlagSOS.FlagSOS"><code>FlagSOS.FlagSOS</code></a></li><li><a href="#FlagSOS.AbstractFlagModel"><code>FlagSOS.AbstractFlagModel</code></a></li><li><a href="#FlagSOS.EqualityModule"><code>FlagSOS.EqualityModule</code></a></li><li><a href="#FlagSOS.Flag"><code>FlagSOS.Flag</code></a></li><li><a href="#FlagSOS.FlagModel"><code>FlagSOS.FlagModel</code></a></li><li><a href="#FlagSOS.Graph"><code>FlagSOS.Graph</code></a></li><li><a href="#FlagSOS.InducedFlag"><code>FlagSOS.InducedFlag</code></a></li><li><a href="#FlagSOS.LasserreModel"><code>FlagSOS.LasserreModel</code></a></li><li><a href="#FlagSOS.PartiallyLabeledFlag"><code>FlagSOS.PartiallyLabeledFlag</code></a></li><li><a href="#FlagSOS.Predicate"><code>FlagSOS.Predicate</code></a></li><li><a href="#FlagSOS.QuadraticModule"><code>FlagSOS.QuadraticModule</code></a></li><li><a href="#FlagSOS.QuantumFlag"><code>FlagSOS.QuantumFlag</code></a></li><li><a href="#FlagSOS.RazborovModel"><code>FlagSOS.RazborovModel</code></a></li><li><a href="#Base.:*-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Flag"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{R}, Tuple{T}, Tuple{R, T}} where {T&lt;:Flag, R&lt;:Real}"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{R}, Tuple{T}, Tuple{T, QuantumFlag{T, R}}} where {T&lt;:Flag, R&lt;:Real}"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{R}, Tuple{T}, Tuple{QuantumFlag{T, R}, QuantumFlag{T, R}}} where {T&lt;:Flag, R&lt;:Real}"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{R}, Tuple{T}, Tuple{R, QuantumFlag{T, R}}} where {T&lt;:Flag, R&lt;:Real}"><code>Base.:*</code></a></li><li><a href="#Base.:*-Union{Tuple{R}, Tuple{T}, Tuple{QuantumFlag{T, R}, T}} where {T&lt;:Flag, R&lt;:Real}"><code>Base.:*</code></a></li><li><a href="#Base.:+-Union{Tuple{R}, Tuple{T}, Tuple{T, QuantumFlag{T, R}}} where {T&lt;:Flag, R&lt;:Real}"><code>Base.:+</code></a></li><li><a href="#Base.:+-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Flag"><code>Base.:+</code></a></li><li><a href="#Base.:+-Union{Tuple{R}, Tuple{T}, Tuple{QuantumFlag{T, R}, QuantumFlag{T, R}}} where {T&lt;:Flag, R&lt;:Real}"><code>Base.:+</code></a></li><li><a href="#Base.:--Tuple{T} where T&lt;:Flag"><code>Base.:-</code></a></li><li><a href="#Base.:--Union{Tuple{R}, Tuple{T}, Tuple{QuantumFlag{T, R}, QuantumFlag{T, R}}} where {T&lt;:Flag, R&lt;:Real}"><code>Base.:-</code></a></li><li><a href="#Base.:--Union{Tuple{QuantumFlag{T, R}}, Tuple{R}, Tuple{T}} where {T&lt;:Flag, R&lt;:Real}"><code>Base.:-</code></a></li><li><a href="#Base.:--Union{Tuple{T}, Tuple{T, T}} where T&lt;:Flag"><code>Base.:-</code></a></li><li><a href="#Base.one-Tuple{T} where T&lt;:Flag"><code>Base.one</code></a></li><li><a href="#Base.one-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Flag"><code>Base.one</code></a></li><li><a href="#Base.size-Tuple{QuantumFlag}"><code>Base.size</code></a></li><li><a href="#Base.size-Tuple{T} where T&lt;:Flag"><code>Base.size</code></a></li><li><a href="#FlagSOS.addLasserreBlock!-Union{Tuple{FlagModel{T, N, D}}, Tuple{D}, Tuple{N}, Tuple{T}} where {T&lt;:Flag, N, D}"><code>FlagSOS.addLasserreBlock!</code></a></li><li><a href="#FlagSOS.addLasserreBlock!-Union{Tuple{D}, Tuple{N}, Tuple{T}, Tuple{FlagModel{T, N, D}, Any}} where {T&lt;:Flag, N, D}"><code>FlagSOS.addLasserreBlock!</code></a></li><li><a href="#FlagSOS.addPredicates-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Vararg{U}}} where {T&lt;:Flag, U&lt;:FlagSOS.Predicate}"><code>FlagSOS.addPredicates</code></a></li><li><a href="#FlagSOS.aut-Tuple{T} where T&lt;:Flag"><code>FlagSOS.aut</code></a></li><li><a href="#FlagSOS.buildJuMPModel-Tuple{T} where T&lt;:FlagSOS.AbstractFlagModel"><code>FlagSOS.buildJuMPModel</code></a></li><li><a href="#FlagSOS.countEdges-Tuple{QuantumFlag}"><code>FlagSOS.countEdges</code></a></li><li><a href="#FlagSOS.countEdges-Tuple{T} where T&lt;:Flag"><code>FlagSOS.countEdges</code></a></li><li><a href="#FlagSOS.distinguish-Union{Tuple{T}, Tuple{T, Int64, BitVector}} where T&lt;:Flag"><code>FlagSOS.distinguish</code></a></li><li><a href="#FlagSOS.findUnknownPredicates-Union{Tuple{U}, Tuple{T}, Tuple{T, Vector{U}}} where {T&lt;:Flag, U&lt;:AbstractVector{Int64}}"><code>FlagSOS.findUnknownPredicates</code></a></li><li><a href="#FlagSOS.generateAll-Union{Tuple{T}, Tuple{Type{T}, Int64, Vector{Int64}}} where T"><code>FlagSOS.generateAll</code></a></li><li><a href="#FlagSOS.glue-Union{Tuple{T}, Tuple{FlagSOS.InducedFlag{T}, FlagSOS.InducedFlag{T}, AbstractVector{Int64}}} where T&lt;:Flag"><code>FlagSOS.glue</code></a></li><li><a href="#FlagSOS.glue-Union{Tuple{Vararg{T}}, Tuple{T}} where T&lt;:Flag"><code>FlagSOS.glue</code></a></li><li><a href="#FlagSOS.glue-Union{Tuple{T}, Tuple{T, T, AbstractVector{Int64}}} where T&lt;:Flag"><code>FlagSOS.glue</code></a></li><li><a href="#FlagSOS.glue-Union{Tuple{T}, Tuple{FlagSOS.PartiallyLabeledFlag{T}, FlagSOS.PartiallyLabeledFlag{T}, AbstractVector{Int64}}} where T&lt;:Flag"><code>FlagSOS.glue</code></a></li><li><a href="#FlagSOS.glueFinite-Union{Tuple{T}, Tuple{Any, T, T, AbstractVector{Int64}}} where T&lt;:Flag"><code>FlagSOS.glueFinite</code></a></li><li><a href="#FlagSOS.isAllowed-Union{Tuple{P}, Tuple{T}, Tuple{T, P}} where {T&lt;:Flag, P&lt;:FlagSOS.Predicate}"><code>FlagSOS.isAllowed</code></a></li><li><a href="#FlagSOS.isAllowed-Tuple{T} where T&lt;:Flag"><code>FlagSOS.isAllowed</code></a></li><li><a href="#FlagSOS.isIsomorphic-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Flag"><code>FlagSOS.isIsomorphic</code></a></li><li><a href="#FlagSOS.isSubFlag-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Flag"><code>FlagSOS.isSubFlag</code></a></li><li><a href="#FlagSOS.isSym-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:Flag"><code>FlagSOS.isSym</code></a></li><li><a href="#FlagSOS.isVariableVertex-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Flag"><code>FlagSOS.isVariableVertex</code></a></li><li><a href="#FlagSOS.isolatedVertices-Tuple{T} where T&lt;:Flag"><code>FlagSOS.isolatedVertices</code></a></li><li><a href="#FlagSOS.isolatedVertices-Tuple{FlagSOS.PartiallyLabeledFlag}"><code>FlagSOS.isolatedVertices</code></a></li><li><a href="#FlagSOS.labelCanonically-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Flag"><code>FlagSOS.labelCanonically</code></a></li><li><a href="#FlagSOS.labelCanonically-Tuple{T} where T&lt;:Flag"><code>FlagSOS.labelCanonically</code></a></li><li><a href="#FlagSOS.labelCanonically-Union{Tuple{QuantumFlag{T, R}}, Tuple{R}, Tuple{T}} where {T&lt;:Flag, R&lt;:Real}"><code>FlagSOS.labelCanonically</code></a></li><li><a href="#FlagSOS.maxPredicateArguments-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Flag"><code>FlagSOS.maxPredicateArguments</code></a></li><li><a href="#FlagSOS.moebius-Union{Tuple{FlagSOS.EdgeMarkedFlag{T}}, Tuple{T}} where T&lt;:Flag"><code>FlagSOS.moebius</code></a></li><li><a href="#FlagSOS.moebius-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Flag"><code>FlagSOS.moebius</code></a></li><li><a href="#FlagSOS.overlaps"><code>FlagSOS.overlaps</code></a></li><li><a href="#FlagSOS.permute-Union{Tuple{T}, Tuple{T, AbstractVector{Int64}}} where T&lt;:Flag"><code>FlagSOS.permute</code></a></li><li><a href="#FlagSOS.possibleValues-Union{Tuple{Type{P}}, Tuple{P}} where P&lt;:FlagSOS.Predicate"><code>FlagSOS.possibleValues</code></a></li><li><a href="#FlagSOS.subFlag-Union{Tuple{T}, Tuple{T, AbstractVector{Int64}}} where T&lt;:Flag"><code>FlagSOS.subFlag</code></a></li><li><a href="#FlagSOS.subFlag-Union{Tuple{T}, Tuple{T, BitVector}} where T&lt;:Flag"><code>FlagSOS.subFlag</code></a></li><li><a href="#FlagSOS.vertexColor-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Flag"><code>FlagSOS.vertexColor</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.FlagSOS" href="#FlagSOS.FlagSOS"><code>FlagSOS.FlagSOS</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">module FlagSOS</code></pre><p>Module for customizable Flag-Sum of Squares problems: Change the type of Flag-Algebra, e.g. graphs, hypergraphs, permutations, order types. Generate fully symmetry reduced finite n, infinite n, flexible Flag SOS hierarchies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagSOS.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.AbstractFlagModel" href="#FlagSOS.AbstractFlagModel"><code>FlagSOS.AbstractFlagModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFlagModel{T&lt;:Flag, N, D}</code></pre><p>An abstract Flag-SOS model. <code>T</code> is the Flag-type used internally, i.e. as variables in the SDP obtained at the end. It may be advantageous to use non-induced Flags internally, even when the model is formulated with induced Flags.</p><p><code>N</code> is either <code>:limit</code>, <code>:variable</code> or an Integer. If <code>N == :limit</code>, then we are in the usual case of Flag Algebras, i.e. the case where the number of vertices goes towards infinity (fastest). If <code>N</code> is an integer, then we are in the case of exactly <code>N</code> vertices (slower). If <code>N == :variable</code>, then the model will be parametrized by a variable, i.e. coefficients will be polynomials in <code>N</code> (slowest).</p><p><code>D</code> is the datatype for the coefficients in the final optimization problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagModels/AbstractFlagModel.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.EqualityModule" href="#FlagSOS.EqualityModule"><code>FlagSOS.EqualityModule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EqualityModule{T&lt;:Flag, U&lt;:Flag, N, D} &lt;: AbstractFlagModel{T, N, D}</code></pre><p>Implements quadratic modules for equalities. Meant to be used as submodel of a <code>CompositeFlagModel</code>. Multiplies all elements of <code>basis</code>, a vector of all relevant Flags of type <code>U</code> with <code>equality</code>, converts the result to type <code>T</code>, and sets it to zero in the resulting optimization problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagModels/QuadraticModule.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.Flag" href="#FlagSOS.Flag"><code>FlagSOS.Flag</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Flag</code></pre><p>An abstract Flag.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L16-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.FlagModel" href="#FlagSOS.FlagModel"><code>FlagSOS.FlagModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FlagModel{T &lt;: Flag, N, D} &lt;: AbstractFlagModel{T, N, D}</code></pre><p>A Flag-model with internal Flag type &#39;T&#39;.</p><p><strong>Parameters</strong></p><ul><li><code>T</code>: Target Flag type</li><li><code>N</code>: Limit parameter, see <code>AbstractFlagModel</code></li><li><code>D</code>: Data type of coefficients of the final optimization problem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagModels/FlagModel.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.Graph" href="#FlagSOS.Graph"><code>FlagSOS.Graph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Graph &lt;: Flag</code></pre><p>A model of a graph, given by its adjacency matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/GraphFlagAlgebra.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.InducedFlag" href="#FlagSOS.InducedFlag"><code>FlagSOS.InducedFlag</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InducedFlag{T} &lt;: Flag where {T &lt;: Flag}</code></pre><p>Turns a given Flag into its induced equivalent. E.g. <code>InducedFlag{Graph}(P2)</code>, where <code>P2 = Graph(Bool[0 0 1; 0 0 1; 1 1 0])</code> is the path on three vertices, describes the Flag corresponding to the induced path density. Only makes sense if there is an equivalent to &quot;edges&quot; in the Flag type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/InducedFlag.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.LasserreModel" href="#FlagSOS.LasserreModel"><code>FlagSOS.LasserreModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LasserreModel{T&lt;:Flag, N, D} &lt;: AbstractFlagModel{T, N, D}</code></pre><p>A fully symmetry reduced Lasserre-style model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagModels/LasserreModel.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.PartiallyLabeledFlag" href="#FlagSOS.PartiallyLabeledFlag"><code>FlagSOS.PartiallyLabeledFlag</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PartiallyLabeledFlag{T} &lt;: Flag where {T&lt;:Flag}</code></pre><p>A Flag <code>F</code> where the first <code>n</code> vertices are labeled. May have isolated vertices in the labeled part. Labeling such a Flag canonically cannot swap vertices in the labeled part, meaning the Flags 2-1-o and 1-2-o are different. If swaps there should be allowed, use a <code>ColoredFlag{T}</code> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/PartiallyLabeledFlag.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.Predicate" href="#FlagSOS.Predicate"><code>FlagSOS.Predicate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Predicate</code></pre><p>A way to describe one predicate value in a Flag. For example, it may describe a single edge of a <code>Graph</code>, or a single label of a <code>PartiallyLabeledFlag</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.QuadraticModule" href="#FlagSOS.QuadraticModule"><code>FlagSOS.QuadraticModule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuadraticModule{T &lt;: Flag, U &lt;: Flag, B &lt;: AbstractFlagModel{U, N, D}, N, D} &lt;: AbstractFlagModel{T, N, D}</code></pre><p>Implements quadractic modules for inequalities. Meant to be used as a submodel of a <code>FlagModel</code>. Multiplies all elements of the <code>baseModel</code> with the <code>inequality</code> and then transforms them to type <code>T</code> (e.g. by unlabeling). The inequality <code>f &gt;= 0</code> is given in form of a <code>QuantumFlag{U}</code> describing <code>f</code>. If both inequalities <code>f &gt;= 0</code> and <code>-f &gt;= 0</code> appear in the problem it is equivalent, but much more efficient, to use an <code>EqualityModule</code> instead.</p><p><strong>Parameters</strong></p><ul><li><code>T</code>: Target Flag type</li><li><code>U</code>: Flag type of the inequality, and the target type of the base model</li><li><code>B</code>: Type of the base model</li><li><code>N</code>: Limit parameter, see <code>AbstractFlagModel</code></li><li><code>D</code>: Data type of coefficients of the final optimization problem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagModels/QuadraticModule.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.QuantumFlag" href="#FlagSOS.QuantumFlag"><code>FlagSOS.QuantumFlag</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct QuantumFlag{F&lt;:Flag, T&lt;:Real}</code></pre><p>A linear combination of Flags of type <code>F</code> with coefficients of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/QuantumFlag.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.RazborovModel" href="#FlagSOS.RazborovModel"><code>FlagSOS.RazborovModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RazborovModel{T&lt;:Flag, N, D} &lt;: AbstractFlagModel{T, N, D}</code></pre><p>A (not fully symmetry reduced) Razborov-style model. If T is an InducedFlag, the hierarchy is the same as the one implemented in Flagmatic. If T is not induced, then a Moebius-transform is applied only on the labeled vertices. The resulting hierarchy is then a basis-transformation of the usual hierarchy, and returns the same bounds, but expressed in non-induced flags.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagModels/RazborovModel.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{R}, Tuple{T}, Tuple{QuantumFlag{T, R}, QuantumFlag{T, R}}} where {T&lt;:Flag, R&lt;:Real}" href="#Base.:*-Union{Tuple{R}, Tuple{T}, Tuple{QuantumFlag{T, R}, QuantumFlag{T, R}}} where {T&lt;:Flag, R&lt;:Real}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">:*(F::QuantumFlag{T,R}, G::QuantumFlag{T, R}) where {T &lt;: Flag, R&lt;:Real}</code></pre><p>The gluing operation of type <code>T</code> extended to linear combinations of Flags.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/QuantumFlag.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{R}, Tuple{T}, Tuple{QuantumFlag{T, R}, T}} where {T&lt;:Flag, R&lt;:Real}" href="#Base.:*-Union{Tuple{R}, Tuple{T}, Tuple{QuantumFlag{T, R}, T}} where {T&lt;:Flag, R&lt;:Real}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">:*(G::QuantumFlag{T, R},F::T) where {T &lt;: Flag, R&lt;:Real}</code></pre><p>The gluing operation of type <code>T</code> extended to linear combinations of Flags.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/QuantumFlag.jl#L208-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{R}, Tuple{T}, Tuple{R, QuantumFlag{T, R}}} where {T&lt;:Flag, R&lt;:Real}" href="#Base.:*-Union{Tuple{R}, Tuple{T}, Tuple{R, QuantumFlag{T, R}}} where {T&lt;:Flag, R&lt;:Real}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">:*(c::R, G::QuantumFlag{T, R}) where {T &lt;: Flag, R&lt;:Real}</code></pre><p>Scalar multiplication of a linear combinations of Flags.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/QuantumFlag.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{R}, Tuple{T}, Tuple{R, T}} where {T&lt;:Flag, R&lt;:Real}" href="#Base.:*-Union{Tuple{R}, Tuple{T}, Tuple{R, T}} where {T&lt;:Flag, R&lt;:Real}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">:*(c::R, G::T) where {T &lt;: Flag, R&lt;:Real}</code></pre><p>Scalar multiplication of Flags. Returns a &#39;QuantumFlag{T, R}&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/QuantumFlag.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{R}, Tuple{T}, Tuple{T, QuantumFlag{T, R}}} where {T&lt;:Flag, R&lt;:Real}" href="#Base.:*-Union{Tuple{R}, Tuple{T}, Tuple{T, QuantumFlag{T, R}}} where {T&lt;:Flag, R&lt;:Real}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">:*(F::T, G::QuantumFlag{T, R}) where {T &lt;: Flag, R&lt;:Real}</code></pre><p>The gluing operation of type <code>T</code> extended to linear combinations of Flags.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/QuantumFlag.jl#L191-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Flag" href="#Base.:*-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Flag"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">:*(F::T, G::T) where {T&lt;:Flag}</code></pre><p>The gluing operation of type <code>T</code>. Should, for example, glue unlabeled vertices to distinct vertices in the result. Default implementation glues the Flags on fully distinct vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Union{Tuple{R}, Tuple{T}, Tuple{QuantumFlag{T, R}, QuantumFlag{T, R}}} where {T&lt;:Flag, R&lt;:Real}" href="#Base.:+-Union{Tuple{R}, Tuple{T}, Tuple{QuantumFlag{T, R}, QuantumFlag{T, R}}} where {T&lt;:Flag, R&lt;:Real}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">:+(F::QuantumFlag{T,R}, G::QuantumFlag{T, R}) where {T &lt;: Flag, R&lt;:Real}</code></pre><p>Adds two linear combinations of Flags.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/QuantumFlag.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Union{Tuple{R}, Tuple{T}, Tuple{T, QuantumFlag{T, R}}} where {T&lt;:Flag, R&lt;:Real}" href="#Base.:+-Union{Tuple{R}, Tuple{T}, Tuple{T, QuantumFlag{T, R}}} where {T&lt;:Flag, R&lt;:Real}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">:+(F::T, G::QuantumFlag{T, R}) where {T &lt;: Flag, R&lt;:Real}</code></pre><p>Adds a flag to a linear combination of flags.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/QuantumFlag.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Flag" href="#Base.:+-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Flag"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">:+(F::T, G::T) where {T &lt;: Flag}</code></pre><p>Adds two Flags. Returns a &#39;QuantumFlag{T, Int}&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/QuantumFlag.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{T} where T&lt;:Flag" href="#Base.:--Tuple{T} where T&lt;:Flag"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">:-(G::T) where {T &lt;: Flag}</code></pre><p>Scalar multiplication of Flags. Returns a &#39;QuantumFlag{T, Int}&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/QuantumFlag.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Union{Tuple{QuantumFlag{T, R}}, Tuple{R}, Tuple{T}} where {T&lt;:Flag, R&lt;:Real}" href="#Base.:--Union{Tuple{QuantumFlag{T, R}}, Tuple{R}, Tuple{T}} where {T&lt;:Flag, R&lt;:Real}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">:-(F::QuantumFlag{T,R}) where {T &lt;: Flag, R&lt;:Real}</code></pre><p>Inverts the sign of a linear combinations of Flags.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/QuantumFlag.jl#L169-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Union{Tuple{R}, Tuple{T}, Tuple{QuantumFlag{T, R}, QuantumFlag{T, R}}} where {T&lt;:Flag, R&lt;:Real}" href="#Base.:--Union{Tuple{R}, Tuple{T}, Tuple{QuantumFlag{T, R}, QuantumFlag{T, R}}} where {T&lt;:Flag, R&lt;:Real}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">:-(F::QuantumFlag{T,R}, G::QuantumFlag{T, R}) where {T &lt;: Flag, R&lt;:Real}</code></pre><p>Subtracts two linear combinations of Flags.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/QuantumFlag.jl#L179-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Union{Tuple{T}, Tuple{T, T}} where T&lt;:Flag" href="#Base.:--Union{Tuple{T}, Tuple{T, T}} where T&lt;:Flag"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">:-(F::T, G::T) where {T &lt;: Flag}</code></pre><p>Subtracts two Flags. Returns a &#39;QuantumFlag{T, Int}&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/QuantumFlag.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.one-Tuple{T} where T&lt;:Flag" href="#Base.one-Tuple{T} where T&lt;:Flag"><code>Base.one</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">one(F::T)::T where {T &lt;: Flag}</code></pre><p>The empty Flag of the same type as <code>F</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.one-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Flag" href="#Base.one-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Flag"><code>Base.one</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">one(F::Type{T})::T where {T &lt;: Flag}</code></pre><p>The empty Flag of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{QuantumFlag}" href="#Base.size-Tuple{QuantumFlag}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size(F::QuantumFlag)</code></pre><p>The maximum size of the Flags in &#39;F&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/QuantumFlag.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{T} where T&lt;:Flag" href="#Base.size-Tuple{T} where T&lt;:Flag"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size(F::T)::Int where {T&lt;:Flag}</code></pre><p>The size (number of vertices) of <code>F</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.addLasserreBlock!-Union{Tuple{D}, Tuple{N}, Tuple{T}, Tuple{FlagModel{T, N, D}, Any}} where {T&lt;:Flag, N, D}" href="#FlagSOS.addLasserreBlock!-Union{Tuple{D}, Tuple{N}, Tuple{T}, Tuple{FlagModel{T, N, D}, Any}} where {T&lt;:Flag, N, D}"><code>FlagSOS.addLasserreBlock!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>addLasserreBlock!(m::FlagModel{T,N,D}, maxEdges::Int; maxVertices = maxEdges * maxPredicateArguments(T)) where {T&lt;:Flag,N,D}</p><p>Adds a symmetry reduced Lasserre block of internal flag type &#39;T&#39; to &#39;m&#39; and returns it. All flags with up to &#39;floor(maxEdges/2)&#39; edges (resp. true predicates) with optionally at most &#39;floor(maxVertices/2)&#39; vertices are added as generators of the block. The resulting hierarchy contains flags with at most &#39;maxEdges&#39; edges and &#39;maxVertices&#39; vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagModels/FlagModel.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.addLasserreBlock!-Union{Tuple{FlagModel{T, N, D}}, Tuple{D}, Tuple{N}, Tuple{T}} where {T&lt;:Flag, N, D}" href="#FlagSOS.addLasserreBlock!-Union{Tuple{FlagModel{T, N, D}}, Tuple{D}, Tuple{N}, Tuple{T}} where {T&lt;:Flag, N, D}"><code>FlagSOS.addLasserreBlock!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>addLasserreBlock!(m::FlagModel{T,N,D}) where {T&lt;:Flag,N,D}</p><p>Adds an empty Lasserre block of internal flag type &#39;T&#39; to &#39;m&#39; and returns it. One should then use &#39;addFlag&#39; to add generators to the block. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagModels/FlagModel.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.addPredicates-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Vararg{U}}} where {T&lt;:Flag, U&lt;:FlagSOS.Predicate}" href="#FlagSOS.addPredicates-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Vararg{U}}} where {T&lt;:Flag, U&lt;:FlagSOS.Predicate}"><code>FlagSOS.addPredicates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addPredicates(::T, ::U, ::Vararg{U} where {T&lt;:Flag,U&lt;:Predicate}</code></pre><p>Creates a copy of <code>F</code>, and adds all predicates with the given values to the copy. May change the order of vertices of <code>F</code>, if necessary (E.g. in the case of <code>PartiallyLabeledFlag</code>). The predicates are given as a Vector of Vectors of Predicate-value pairs, sorted by type in a way that <code>addPredicates</code> understands.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.aut-Tuple{T} where T&lt;:Flag" href="#FlagSOS.aut-Tuple{T} where T&lt;:Flag"><code>FlagSOS.aut</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aut(F::T)::NamedTuple{(:gen, :size),Tuple{Vector{Vector{Int64}},Int64}} where {T&lt;:Flag}</code></pre><p>The automorphisms of <code>F</code>. Returns a named tuple with fields</p><ul><li><code>gen::Vector{Vector{Int}}</code>: Vector of permutations generating all automorphisms.</li><li><code>size::Int</code>: The size of the automorphism group of <code>F</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L109-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.buildJuMPModel-Tuple{T} where T&lt;:FlagSOS.AbstractFlagModel" href="#FlagSOS.buildJuMPModel-Tuple{T} where T&lt;:FlagSOS.AbstractFlagModel"><code>FlagSOS.buildJuMPModel</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns (Variables, Constraints)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagModels/AbstractFlagModel.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.countEdges-Tuple{QuantumFlag}" href="#FlagSOS.countEdges-Tuple{QuantumFlag}"><code>FlagSOS.countEdges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">countEdges(F::QuantumFlag)</code></pre><p>The maximum number of edges of the flags in &#39;F&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/QuantumFlag.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.countEdges-Tuple{T} where T&lt;:Flag" href="#FlagSOS.countEdges-Tuple{T} where T&lt;:Flag"><code>FlagSOS.countEdges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">countEdges(F::T)::Vector{Int} where {T&lt;:Flag}</code></pre><p>Returns the Vector of numbers of set predicates in the Flag <code>F</code> for each <code>Predicate</code> type. For Graphs, this is the Vector with one element, the number of edges in the graph. Used when generating all Flags up to isomorphism of a given type to specify an upper bound on the number of set predicates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L313-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.distinguish-Union{Tuple{T}, Tuple{T, Int64, BitVector}} where T&lt;:Flag" href="#FlagSOS.distinguish-Union{Tuple{T}, Tuple{T, Int64, BitVector}} where T&lt;:Flag"><code>FlagSOS.distinguish</code></a> — <span class="docstring-category">Method</span></header><section><div><p>distinguish(F::T, v::Int, W::BitVector) where {T&lt;:Flag}</p><p>Given a Flag <code>F</code>, a vertex <code>v</code> and a subset of vertices indicated by <code>W</code>, distinguish <code>v</code> by analyzing it&#39;s relationship to the vertices <code>W</code>. This may, for example, be the number of edges between <code>v</code> and the cell <code>W</code>, or the number of triangles with <code>v</code> and one/two vertices of <code>W</code>. The type of result does not matter, as it does get hashed after.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L349-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.findUnknownPredicates-Union{Tuple{U}, Tuple{T}, Tuple{T, Vector{U}}} where {T&lt;:Flag, U&lt;:AbstractVector{Int64}}" href="#FlagSOS.findUnknownPredicates-Union{Tuple{U}, Tuple{T}, Tuple{T, Vector{U}}} where {T&lt;:Flag, U&lt;:AbstractVector{Int64}}"><code>FlagSOS.findUnknownPredicates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findUnknownPredicates(F::T, fixed::Vector{Vector{Int}})</code></pre><p>Given a Flag <code>T</code>, as well as subsets of vertices such that predicates (e.g. edges) are fixed if all arguments are within one of these sets. One should return a <code>Predicate</code> for each predicate and each combination of arguments, such that not all arguments are contained in one of the fixed subsets. The function returns a Vector of Vectors of Predicates, such that  should return a Vector of Vectors of Predicates <code>addPredicates</code> can understand it.</p><p>This is then used to determine the glued Flag in induced settings. For example, gluing the partially labelled edge 1-o to itself, would call</p><pre><code class="nohighlight hljs">findUnknownPredicates(Graph(Bool[0 1 1; 1 0 0; 1 0 0]), [[1,2],[1,3]])</code></pre><p>The only unclear predicate here is the edge [2,3], i.e. this function should return</p><pre><code class="nohighlight hljs">[[EdgePredicate(2,3)]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L291-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.generateAll-Union{Tuple{T}, Tuple{Type{T}, Int64, Vector{Int64}}} where T" href="#FlagSOS.generateAll-Union{Tuple{T}, Tuple{Type{T}, Int64, Vector{Int64}}} where T"><code>FlagSOS.generateAll</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generateAll(::Type{F}, maxVertices::Int, maxPredicates::Vector{Int}) where {F}</code></pre><p>Generates all Flags of type <code>F</code> with up to <code>maxVertices</code> vertices and up to <code>maxPredicates</code> non-zero predicate values. &#39;maxPredicates&#39; is a vector, for the case that there are multiple predicates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/utils/Nauty.jl#L264-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.glue-Union{Tuple{T}, Tuple{FlagSOS.InducedFlag{T}, FlagSOS.InducedFlag{T}, AbstractVector{Int64}}} where T&lt;:Flag" href="#FlagSOS.glue-Union{Tuple{T}, Tuple{FlagSOS.InducedFlag{T}, FlagSOS.InducedFlag{T}, AbstractVector{Int64}}} where T&lt;:Flag"><code>FlagSOS.glue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">glue(F::InducedFlag{T}, G::InducedFlag{T}, p::Vector{Int})</code></pre><p>Glues together the two induced Flags <code>F</code> and <code>G</code>, after applying the permutation <code>p</code> to the vertices of <code>F</code>. <code>p</code> may be a permutation involving more than <code>size(F)</code> vertices. Since these Flags describe induced densities, the result is a linear combination of every possible combination of &quot;unknown&quot; edges between the added vertices from eachothers perspectives (or equivalent). If the common part is different, they are orthogonal to each other and thus return an empty Vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/InducedFlag.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.glue-Union{Tuple{T}, Tuple{FlagSOS.PartiallyLabeledFlag{T}, FlagSOS.PartiallyLabeledFlag{T}, AbstractVector{Int64}}} where T&lt;:Flag" href="#FlagSOS.glue-Union{Tuple{T}, Tuple{FlagSOS.PartiallyLabeledFlag{T}, FlagSOS.PartiallyLabeledFlag{T}, AbstractVector{Int64}}} where T&lt;:Flag"><code>FlagSOS.glue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">glue(F::PartiallyLabeledFlag{T}, G::PartiallyLabeledFlag{T}, p::Vector{Int})</code></pre><p>Glues together the two partially labeled Flags <code>F</code> and <code>G</code>, after applying the permutation <code>p</code> to the vertices of <code>F</code>. <code>p</code> may be a permutation involving more than <code>size(F)</code> vertices, but should send the labeled part of <code>F</code> to the labeled part of <code>G</code>, without permuting indices there.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/PartiallyLabeledFlag.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.glue-Union{Tuple{T}, Tuple{T, T, AbstractVector{Int64}}} where T&lt;:Flag" href="#FlagSOS.glue-Union{Tuple{T}, Tuple{T, T, AbstractVector{Int64}}} where T&lt;:Flag"><code>FlagSOS.glue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">glue(F::T, G::T, p::Vector{Int})::U where {T&lt;:Flag, U&lt;:Flag}</code></pre><p>Glues together the two Flags <code>F</code> and <code>G</code>, after applying the permutation <code>p</code> to the vertices of <code>F</code>. <code>p</code> may be a permutation involving more than <code>size(F)</code> vertices, in which case the result should have at least <code>maximum(p)</code> vertices. Optionally specifices a different output Flag type, for cases where the internal Flag type differs and there are performance advantages (such as the case of internal non-induced Graphs and the gluing of two induced Graphs).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L132-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.glue-Union{Tuple{Vararg{T}}, Tuple{T}} where T&lt;:Flag" href="#FlagSOS.glue-Union{Tuple{Vararg{T}}, Tuple{T}} where T&lt;:Flag"><code>FlagSOS.glue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">glue(Fs::Vararg{T}) where {T&lt;:Flag}</code></pre><p>Glues Flags together &quot;on top of each other&quot;. Optionally specifices the output Flag type, for cases where a different type may improve performance (E.g. non-induced Flag as target for the gluing of two induced Flags). The default implementation only uses the custom type for the final gluing.</p><pre><code class="nohighlight hljs">glue(F, G, H)</code></pre><p>is equivalent to</p><pre><code class="nohighlight hljs">glue(F, glue(G, H, 1:size(G)), 1:size(F))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L143-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.glueFinite-Union{Tuple{T}, Tuple{Any, T, T, AbstractVector{Int64}}} where T&lt;:Flag" href="#FlagSOS.glueFinite-Union{Tuple{T}, Tuple{Any, T, T, AbstractVector{Int64}}} where T&lt;:Flag"><code>FlagSOS.glueFinite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">glueFinite(N, F::T, G::T, p::AbstractVector{Int}; labelFlags = true) where {T&lt;:Flag}</code></pre><p>Glues together the flags <code>F</code> and <code>G</code>, after applying the permutation <code>p</code> to the vertices of <code>F</code>. This variant of <code>glue</code> is for optimizing over finite objects, given by <code>N</code> which should be one of the options <code>:limit</code>, <code>:variable</code> or an integer. The operation assumes the k vertices that are sent on top of each other by <code>p</code> correspond to labels, and assumes that the other vertices are unlabeled, i.e. get sent to all <code>N-k</code> other vertices. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.isAllowed-Tuple{T} where T&lt;:Flag" href="#FlagSOS.isAllowed-Tuple{T} where T&lt;:Flag"><code>FlagSOS.isAllowed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isAllowed(F::T) where {T&lt;:Flag}</code></pre><p>Sometimes one may want to create a flag-algebra with inherently forbidden flags, instead of attaching it to a model. Then one should implement (or locally overwrite) this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L415-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.isAllowed-Union{Tuple{P}, Tuple{T}, Tuple{T, P}} where {T&lt;:Flag, P&lt;:FlagSOS.Predicate}" href="#FlagSOS.isAllowed-Union{Tuple{P}, Tuple{T}, Tuple{T, P}} where {T&lt;:Flag, P&lt;:FlagSOS.Predicate}"><code>FlagSOS.isAllowed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isAllowed(F::T, e::P) where {T&lt;:Flag, P&lt;:Predicate}</code></pre><p>Sometimes one may want to create a flag-algebra with inherently forbidden flags, instead of attaching it to a model. This function should return true iff the predicate P can be set to true (i.e. the edge P can be added).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L424-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.isIsomorphic-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Flag" href="#FlagSOS.isIsomorphic-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Flag"><code>FlagSOS.isIsomorphic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isIsomorphic(F::T, G::T) where {T&lt;:Flag}</code></pre><p>Checks if two flags are isomorphic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L379-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.isSubFlag-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Flag" href="#FlagSOS.isSubFlag-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Flag"><code>FlagSOS.isSubFlag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isSubFlag(F::T, G::T) where {T&lt;:Flag}</code></pre><p>Checks if &#39;F&#39; appears as sub-flag of &#39;G&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L390-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.isSym-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:Flag" href="#FlagSOS.isSym-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T&lt;:Flag"><code>FlagSOS.isSym</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isSym(F::T, v1::Int, v2::Int)::Bool where {T&lt;:Flag}</code></pre><p>Returns true if the permutation which swaps the vertices <code>v1</code> and <code>v2</code> is an automorphism of <code>F</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L260-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.isVariableVertex-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Flag" href="#FlagSOS.isVariableVertex-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Flag"><code>FlagSOS.isVariableVertex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isVariableVertex(F::T, v::Int) where {T&lt;:Flag}</code></pre><p>Returns true if vertex <code>v</code> is one of the &quot;variable vertices&quot;, i.e. vertices of which the number goes towards infinity. Per default, it always returns true. But, for example, for partially labeled Flags, it only returns true if the vertex is unlabeled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L359-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.isolatedVertices-Tuple{FlagSOS.PartiallyLabeledFlag}" href="#FlagSOS.isolatedVertices-Tuple{FlagSOS.PartiallyLabeledFlag}"><code>FlagSOS.isolatedVertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isolatedVertices(F::PartiallyLabeledFlag)::BitVector</code></pre><p>Returns the isolated, and un-labeled vertices of <code>F</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/PartiallyLabeledFlag.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.isolatedVertices-Tuple{T} where T&lt;:Flag" href="#FlagSOS.isolatedVertices-Tuple{T} where T&lt;:Flag"><code>FlagSOS.isolatedVertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isolatedVertices(F::T)::Vector{Int} where{T&lt;:Flag}</code></pre><p>Returns the indicator vector of isolated vertices of <code>F</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L324-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.labelCanonically-Tuple{T} where T&lt;:Flag" href="#FlagSOS.labelCanonically-Tuple{T} where T&lt;:Flag"><code>FlagSOS.labelCanonically</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">labelCanonically(F::T)::T where {T &lt;: Flag}</code></pre><p>Labels <code>F</code> canonically. If two Flags are isomorphic, this function should return the same Flag.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L123-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.labelCanonically-Union{Tuple{QuantumFlag{T, R}}, Tuple{R}, Tuple{T}} where {T&lt;:Flag, R&lt;:Real}" href="#FlagSOS.labelCanonically-Union{Tuple{QuantumFlag{T, R}}, Tuple{R}, Tuple{T}} where {T&lt;:Flag, R&lt;:Real}"><code>FlagSOS.labelCanonically</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">labelCanonically(F::QuantumFlag{T,R})::QuantumFlag{T,R} where {T &lt;: Flag, R &lt;: Real}</code></pre><p>Labels <code>F</code> canonically. If two Flags are isomorphic, this function should return the same Flag.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/QuantumFlag.jl#L218-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.labelCanonically-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Flag" href="#FlagSOS.labelCanonically-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Flag"><code>FlagSOS.labelCanonically</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">labelCanonically(Fs::Vector{T})::Vector{T} where {T &lt;: Flag}</code></pre><p>Labels all Flags in <code>Fs</code> canonically. If two Flags are isomorphic, this function should return the same Flag.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/QuantumFlag.jl#L240-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.maxPredicateArguments-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Flag" href="#FlagSOS.maxPredicateArguments-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Flag"><code>FlagSOS.maxPredicateArguments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maxPredicateArguments(::Type{T}) where {T&lt;:Flag}</code></pre><p>Maximum number of arguments of a predicate in the theory &#39;T&#39;. For instance, this is &#39;2&#39; for graphs, as the only predicate, the edge predicate, takes two arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L369-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.moebius-Union{Tuple{FlagSOS.EdgeMarkedFlag{T}}, Tuple{T}} where T&lt;:Flag" href="#FlagSOS.moebius-Union{Tuple{FlagSOS.EdgeMarkedFlag{T}}, Tuple{T}} where T&lt;:Flag"><code>FlagSOS.moebius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">moebius(F::EdgeMarkedFlag{T}) where {T&lt;:Flag}</code></pre><p>Computes the moebius transform of an edge-marked flag on the marked edges. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/EdgeMarkedFlag.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.moebius-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Flag" href="#FlagSOS.moebius-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Flag"><code>FlagSOS.moebius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">moebius(F::T, verts = 1:size(F)) where {T&lt;:Flag}</code></pre><p>Computes the moebius transform of a flag on the vertices &#39;verts&#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/EdgeMarkedFlag.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.overlaps" href="#FlagSOS.overlaps"><code>FlagSOS.overlaps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">overlaps(lambda, mu [, total = pN, limit::Bool = false, fixedN = false])</code></pre><p>Calculate the different ways two partitions can overlap, with multiplicities. Lambda is considered fixed, mu changes. Adds a biggest dynamic part by (lambda,n-sum(lambda)). Result is array of pairs, first is multiplicity depending on n, second is matrix. Rows are lambda i (last is dynamic sized), columns are mu i (last is dynamic sized)</p><p>To get the total amount of combinations (i.e. lambda can move around, too), multiply all multiplicities with numSplits(lambda). We have overlaps(lambda,mu) * numsplits(lambda) == overlaps(mu,lambda) * numSplits(mu).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; overlaps([1],[2])
2-element Array{Any,1}:
 (1//2*n^2-3//2*n+1//1, [0 2; 1 0])
 (n-1//1, [1 1; 0 0])</code></pre><p>Corresponds to the two ways the partitions (1,n-1) and (2,n-2) can overlap. The first element is the overlap, where the 2-part of mu lies in the n-1 part of lambda, with multiplicity n-1 choose 2. The second is the one where 1 element of the 2-part of mu lies in the 1-part of lambda, with multiplicity n-1 choose 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/PartitionOverlaps.jl#L62-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.permute-Union{Tuple{T}, Tuple{T, AbstractVector{Int64}}} where T&lt;:Flag" href="#FlagSOS.permute-Union{Tuple{T}, Tuple{T, AbstractVector{Int64}}} where T&lt;:Flag"><code>FlagSOS.permute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">permute(F::T, p::AbstractVector{Int})::T where {T&lt;:Flag}</code></pre><p>Permutes the vertices of <code>F</code> according to the permutation <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L250-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.possibleValues-Union{Tuple{Type{P}}, Tuple{P}} where P&lt;:FlagSOS.Predicate" href="#FlagSOS.possibleValues-Union{Tuple{Type{P}}, Tuple{P}} where P&lt;:FlagSOS.Predicate"><code>FlagSOS.possibleValues</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">possibleValues(::Type{P}) where {P&lt;:Predicate}</code></pre><p>Returns the possible non-zero (!) values of a predicate of type <code>P</code>. Usually just <code>[true]</code>, but for example directed graphs (without possiblity of a bi-directional edge) may have predicate values 0, 1 and -1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.subFlag-Union{Tuple{T}, Tuple{T, AbstractVector{Int64}}} where T&lt;:Flag" href="#FlagSOS.subFlag-Union{Tuple{T}, Tuple{T, AbstractVector{Int64}}} where T&lt;:Flag"><code>FlagSOS.subFlag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subFlag(F::T, vertices::AbstractVector{Int})::T where {T&lt;:Flag}</code></pre><p>Returns the sub-Flag indexed by <code>vertices</code>, which is a subset of <code>1:size(F)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L270-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.subFlag-Union{Tuple{T}, Tuple{T, BitVector}} where T&lt;:Flag" href="#FlagSOS.subFlag-Union{Tuple{T}, Tuple{T, BitVector}} where T&lt;:Flag"><code>FlagSOS.subFlag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subFlag(F::T, vertices::BitVector)::T where {T&lt;:Flag}</code></pre><p>Returns the sub-Flag given by the indicator vector <code>vertices</code>, which is a <code>BitVector</code> of length <code>size(F)</code>. If not extended, it calls <code>subFlag(F, findall(vertices))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L280-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FlagSOS.vertexColor-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Flag" href="#FlagSOS.vertexColor-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Flag"><code>FlagSOS.vertexColor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vertexColor(::T, ::Int) where {T&lt;:Flag}</code></pre><p>Returns the color of vertices in colored Flags. The default is the case of a vertex-transitive Flags-type, where all vertices have color <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielBrosch/FlagSOS.jl/blob/bd85557d8547b8c7b33e2b52ada7703af2714dee/src/FlagAlgebras/AbstractFlagAlgebra.jl#L340-L344">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="examples/TriangleFreeGraphs/">Basic example: Mantel&#39;s theorem »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 12 September 2023 09:46">Tuesday 12 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
