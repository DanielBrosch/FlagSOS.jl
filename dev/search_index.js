var documenterSearchIndex = {"docs":
[{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"EditURL = \"ErrorCorrectingCodes.jl\"","category":"page"},{"location":"examples/ErrorCorrectingCodes/#Finite-high-precision-example:-Error-correcting-codes","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"","category":"section"},{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"A constant weight error correcting code of length N, distance D and weight W is a set of binary words of length N, each of which has exactly W ones, where every pair of words differs in at least D coordinates. Here we bound the maximum cardinality of such a code, and solve the SDP to a high precision.","category":"page"},{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"using FlagSOS","category":"page"},{"location":"examples/ErrorCorrectingCodes/#Setting-up-the-model","page":"Finite + high precision example: Error correcting codes","title":"Setting up the model","text":"","category":"section"},{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"N = 11 # length\nW = 3  # weight\nD = 4;  # distance\nnothing #hide","category":"page"},{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"The type ConstantWeightCode{W,D} models all codes with constant weight W and minimum distance D, independent of its length N.","category":"page"},{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"const WDCode = ConstantWeightCode{W,D}","category":"page"},{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"We start by creating an empty FlagModel for WDCodes of length N. Since N is finite, we need Rational{Int} coefficients.","category":"page"},{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"m = FlagModel{WDCode,N,Rational{Int}}();\nnothing #hide","category":"page"},{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"We want to maximize the cardinality of the code, i.e. the density of the subcode containing just one word of weight W.","category":"page"},{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"e = WDCode(ones(Bool, 1, W))\nm.objective = -1 * e","category":"page"},{"location":"examples/ErrorCorrectingCodes/#Initializing-the-Razborov-hierarchy","page":"Finite + high precision example: Error correcting codes","title":"Initializing the Razborov hierarchy","text":"","category":"section"},{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"We chose to work with the Razborov hierarchy at level 6, which is based on densities of subcodes fully contained in lvl coordinates of the code. This is the same hierarchy Flagmatic uses.","category":"page"},{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"lvl = 6\nrM = RazborovModel{WDCode,N,Rational{Int}}()\ncomputeRazborovBasis!(rM, lvl)\npush!(m.subModels, rM);\n#block sizes:\nmodelBlockSizes(rM)","category":"page"},{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"We still need to compute the coefficients of the actual optimization problem","category":"page"},{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"computeSDP!(m)","category":"page"},{"location":"examples/ErrorCorrectingCodes/#Solving-the-SDP","page":"Finite + high precision example: Error correcting codes","title":"Solving the SDP","text":"","category":"section"},{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"Now we can solve it to a high precision","category":"page"},{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"using Hypatia, JuMP\nsetprecision(256)\nM = buildJuMPModel(m, Dict(), GenericModel{BigFloat}());\nset_optimizer(M.model, Hypatia.Optimizer{BigFloat})\noptimize!(M.model)","category":"page"},{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"termination_status(M.model)","category":"page"},{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"We need to turn the density of the code to its cardinality","category":"page"},{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"objective_value(M.model) * binomial(N, W)","category":"page"},{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"","category":"page"},{"location":"examples/ErrorCorrectingCodes/","page":"Finite + high precision example: Error correcting codes","title":"Finite + high precision example: Error correcting codes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/TriangleFreeGraphs/","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"EditURL = \"TriangleFreeGraphs.jl\"","category":"page"},{"location":"examples/TriangleFreeGraphs/#Basic-example:-Mantel's-theorem","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"","category":"section"},{"location":"examples/TriangleFreeGraphs/","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"The maximum edge density in triangle free graphs is well known to be frac12, as was first proven by Mantel in 1907. Here we give an automatic proof.","category":"page"},{"location":"examples/TriangleFreeGraphs/","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"using FlagSOS","category":"page"},{"location":"examples/TriangleFreeGraphs/#Setting-up-the-model","page":"Basic example: Mantel's theorem","title":"Setting up the model","text":"","category":"section"},{"location":"examples/TriangleFreeGraphs/","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"We define the relevant graphs using their adjacency matrices.","category":"page"},{"location":"examples/TriangleFreeGraphs/","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"edge = Graph(Bool[0 1; 1 0]);\ntriangle = Graph(Bool[0 1 1; 1 0 1; 1 1 0]);\nnothing #hide","category":"page"},{"location":"examples/TriangleFreeGraphs/","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"We start with an empty FlagModel of type Graph, where we forbid the triangle graph (and all graphs containing it):","category":"page"},{"location":"examples/TriangleFreeGraphs/","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"m = FlagModel{Graph}()\naddForbiddenFlag(m, triangle)","category":"page"},{"location":"examples/TriangleFreeGraphs/#Choosing-a-relaxation","page":"Basic example: Mantel's theorem","title":"Choosing a relaxation","text":"","category":"section"},{"location":"examples/TriangleFreeGraphs/","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"Now we need to choose a hierarchy. One option is the Lasserre hierarchy, which we can attach to the model using addLasserreBlock!.","category":"page"},{"location":"examples/TriangleFreeGraphs/","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"addLasserreBlock!(m, 4);\nnothing #hide","category":"page"},{"location":"examples/TriangleFreeGraphs/","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"This results in a semidefinite programming problem with block sizes","category":"page"},{"location":"examples/TriangleFreeGraphs/","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"modelSize(m)","category":"page"},{"location":"examples/TriangleFreeGraphs/","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"We want to maximize the edge density, which we can do by minimizing its negative","category":"page"},{"location":"examples/TriangleFreeGraphs/","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"m.objective = -1 * edge","category":"page"},{"location":"examples/TriangleFreeGraphs/","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"Finally, we compute the coefficients of the SDP.","category":"page"},{"location":"examples/TriangleFreeGraphs/","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"computeSDP!(m)","category":"page"},{"location":"examples/TriangleFreeGraphs/#Solving-the-SDP","page":"Basic example: Mantel's theorem","title":"Solving the SDP","text":"","category":"section"},{"location":"examples/TriangleFreeGraphs/","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"We solve the relaxation using Hypatia.","category":"page"},{"location":"examples/TriangleFreeGraphs/","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"using Hypatia, JuMP\njm = buildJuMPModel(m)\nset_optimizer(jm.model, Hypatia.Optimizer)\noptimize!(jm.model)\ntermination_status(jm.model)","category":"page"},{"location":"examples/TriangleFreeGraphs/","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"objective_value(jm.model)","category":"page"},{"location":"examples/TriangleFreeGraphs/","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"","category":"page"},{"location":"examples/TriangleFreeGraphs/","page":"Basic example: Mantel's theorem","title":"Basic example: Mantel's theorem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FlagSOS","category":"page"},{"location":"#FlagSOS","page":"Home","title":"FlagSOS","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FlagSOS.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [FlagSOS]","category":"page"},{"location":"#FlagSOS.FlagSOS","page":"Home","title":"FlagSOS.FlagSOS","text":"module FlagSOS\n\nModule for customizable Flag-Sum of Squares problems: Change the type of Flag-Algebra, e.g. graphs, hypergraphs, permutations, order types. Generate fully symmetry reduced finite n, infinite n, flexible Flag SOS hierarchies.\n\n\n\n\n\n","category":"module"},{"location":"#FlagSOS.AbstractFlagModel","page":"Home","title":"FlagSOS.AbstractFlagModel","text":"AbstractFlagModel{T<:Flag, N, D}\n\nAn abstract Flag-SOS model. T is the Flag-type used internally, i.e. as variables in the SDP obtained at the end. It may be advantageous to use non-induced Flags internally, even when the model is formulated with induced Flags.\n\nN is either :limit, :variable or an Integer. If N == :limit, then we are in the usual case of Flag Algebras, i.e. the case where the number of vertices goes towards infinity (fastest). If N is an integer, then we are in the case of exactly N vertices (slower). If N == :variable, then the model will be parametrized by a variable, i.e. coefficients will be polynomials in N (slowest).\n\nD is the datatype for the coefficients in the final optimization problem.\n\n\n\n\n\n","category":"type"},{"location":"#FlagSOS.DirectedGraph","page":"Home","title":"FlagSOS.DirectedGraph","text":"struct DirectedGraph{allowDigons} <: Flag\n\nA model of a directed graph, given by its adjacency matrix.\n\n\n\n\n\n","category":"type"},{"location":"#FlagSOS.EqualityModule","page":"Home","title":"FlagSOS.EqualityModule","text":"EqualityModule{T<:Flag, U<:Flag, N, D} <: AbstractFlagModel{T, N, D}\n\nImplements quadratic modules for equalities. Meant to be used as submodel of a CompositeFlagModel. Multiplies all elements of basis, a vector of all relevant Flags of type U with equality, converts the result to type T, and sets it to zero in the resulting optimization problem.\n\n\n\n\n\n","category":"type"},{"location":"#FlagSOS.Flag","page":"Home","title":"FlagSOS.Flag","text":"abstract type Flag\n\nAn abstract Flag.\n\n\n\n\n\n","category":"type"},{"location":"#FlagSOS.FlagModel","page":"Home","title":"FlagSOS.FlagModel","text":"FlagModel{T <: Flag, N, D} <: AbstractFlagModel{T, N, D}\n\nA Flag-model with internal Flag type 'T'.\n\nParameters\n\nT: Target Flag type\nN: Limit parameter, see AbstractFlagModel\nD: Data type of coefficients of the final optimization problem\n\n\n\n\n\n","category":"type"},{"location":"#FlagSOS.Graph","page":"Home","title":"FlagSOS.Graph","text":"struct Graph <: Flag\n\nA model of a graph, given by its adjacency matrix.\n\n\n\n\n\n","category":"type"},{"location":"#FlagSOS.InducedFlag","page":"Home","title":"FlagSOS.InducedFlag","text":"InducedFlag{T} <: Flag where {T <: Flag}\n\nTurns a given Flag into its induced equivalent. E.g. InducedFlag{Graph}(P2), where P2 = Graph(Bool[0 0 1; 0 0 1; 1 1 0]) is the path on three vertices, describes the Flag corresponding to the induced path density. Only makes sense if there is an equivalent to \"edges\" in the Flag type T.\n\n\n\n\n\n","category":"type"},{"location":"#FlagSOS.LasserreModel","page":"Home","title":"FlagSOS.LasserreModel","text":"LasserreModel{T<:Flag, N, D} <: AbstractFlagModel{T, N, D}\n\nA fully symmetry reduced Lasserre-style model.\n\n\n\n\n\n","category":"type"},{"location":"#FlagSOS.PartiallyLabeledFlag","page":"Home","title":"FlagSOS.PartiallyLabeledFlag","text":"PartiallyLabeledFlag{T} <: Flag where {T<:Flag}\n\nA Flag F where the first n vertices are labeled. May have isolated vertices in the labeled part. Labeling such a Flag canonically cannot swap vertices in the labeled part, meaning the Flags 2-1-o and 1-2-o are different. If swaps there should be allowed, use a ColoredFlag{T} instead.\n\n\n\n\n\n","category":"type"},{"location":"#FlagSOS.Predicate","page":"Home","title":"FlagSOS.Predicate","text":"abstract type Predicate\n\nA way to describe one predicate value in a Flag. For example, it may describe a single edge of a Graph, or a single label of a PartiallyLabeledFlag.\n\n\n\n\n\n","category":"type"},{"location":"#FlagSOS.QuadraticModule","page":"Home","title":"FlagSOS.QuadraticModule","text":"QuadraticModule{T <: Flag, U <: Flag, B <: AbstractFlagModel{U, N, D}, N, D} <: AbstractFlagModel{T, N, D}\n\nImplements quadractic modules for inequalities. Meant to be used as a submodel of a FlagModel. Multiplies all elements of the baseModel with the inequality and then transforms them to type T (e.g. by unlabeling). The inequality f >= 0 is given in form of a QuantumFlag{U} describing f. If both inequalities f >= 0 and -f >= 0 appear in the problem it is equivalent, but much more efficient, to use an EqualityModule instead.\n\nParameters\n\nT: Target Flag type\nU: Flag type of the inequality, and the target type of the base model\nB: Type of the base model\nN: Limit parameter, see AbstractFlagModel\nD: Data type of coefficients of the final optimization problem\n\n\n\n\n\n","category":"type"},{"location":"#FlagSOS.QuantumFlag","page":"Home","title":"FlagSOS.QuantumFlag","text":"mutable struct QuantumFlag{F<:Flag, T<:Real}\n\nA linear combination of Flags of type F with coefficients of type T.\n\n\n\n\n\n","category":"type"},{"location":"#FlagSOS.RazborovModel","page":"Home","title":"FlagSOS.RazborovModel","text":"RazborovModel{T<:Flag, N, D} <: AbstractFlagModel{T, N, D}\n\nA (not fully symmetry reduced) Razborov-style model. If T is an InducedFlag, the hierarchy is the same as the one implemented in Flagmatic. If T is not induced, then a Moebius-transform is applied only on the labeled vertices. The resulting hierarchy is then a basis-transformation of the usual hierarchy, and returns the same bounds, but expressed in non-induced flags.\n\n\n\n\n\n","category":"type"},{"location":"#Base.:*-Union{Tuple{R}, Tuple{T}, Tuple{QuantumFlag{T, R}, QuantumFlag{T, R}}} where {T<:Flag, R<:Real}","page":"Home","title":"Base.:*","text":":*(F::QuantumFlag{T,R}, G::QuantumFlag{T, R}) where {T <: Flag, R<:Real}\n\nThe gluing operation of type T extended to linear combinations of Flags.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{R}, Tuple{T}, Tuple{QuantumFlag{T, R}, T}} where {T<:Flag, R<:Real}","page":"Home","title":"Base.:*","text":":*(G::QuantumFlag{T, R},F::T) where {T <: Flag, R<:Real}\n\nThe gluing operation of type T extended to linear combinations of Flags.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{R}, Tuple{T}, Tuple{R, QuantumFlag{T, R}}} where {T<:Flag, R<:Real}","page":"Home","title":"Base.:*","text":":*(c::R, G::QuantumFlag{T, R}) where {T <: Flag, R<:Real}\n\nScalar multiplication of a linear combinations of Flags.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{R}, Tuple{T}, Tuple{R, T}} where {T<:Flag, R<:Real}","page":"Home","title":"Base.:*","text":":*(c::R, G::T) where {T <: Flag, R<:Real}\n\nScalar multiplication of Flags. Returns a 'QuantumFlag{T, R}'.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{R}, Tuple{T}, Tuple{T, QuantumFlag{T, R}}} where {T<:Flag, R<:Real}","page":"Home","title":"Base.:*","text":":*(F::T, G::QuantumFlag{T, R}) where {T <: Flag, R<:Real}\n\nThe gluing operation of type T extended to linear combinations of Flags.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Union{Tuple{T}, Tuple{T, T}} where T<:Flag","page":"Home","title":"Base.:*","text":":*(F::T, G::T) where {T<:Flag}\n\nThe gluing operation of type T. Should, for example, glue unlabeled vertices to distinct vertices in the result. Default implementation glues the Flags on fully distinct vertices.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Union{Tuple{R}, Tuple{T}, Tuple{QuantumFlag{T, R}, QuantumFlag{T, R}}} where {T<:Flag, R<:Real}","page":"Home","title":"Base.:+","text":":+(F::QuantumFlag{T,R}, G::QuantumFlag{T, R}) where {T <: Flag, R<:Real}\n\nAdds two linear combinations of Flags.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Union{Tuple{R}, Tuple{T}, Tuple{T, QuantumFlag{T, R}}} where {T<:Flag, R<:Real}","page":"Home","title":"Base.:+","text":":+(F::T, G::QuantumFlag{T, R}) where {T <: Flag, R<:Real}\n\nAdds a flag to a linear combination of flags.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Union{Tuple{T}, Tuple{T, T}} where T<:Flag","page":"Home","title":"Base.:+","text":":+(F::T, G::T) where {T <: Flag}\n\nAdds two Flags. Returns a 'QuantumFlag{T, Int}'.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Tuple{T} where T<:Flag","page":"Home","title":"Base.:-","text":":-(G::T) where {T <: Flag}\n\nScalar multiplication of Flags. Returns a 'QuantumFlag{T, Int}'.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Union{Tuple{QuantumFlag{T, R}}, Tuple{R}, Tuple{T}} where {T<:Flag, R<:Real}","page":"Home","title":"Base.:-","text":":-(F::QuantumFlag{T,R}) where {T <: Flag, R<:Real}\n\nInverts the sign of a linear combinations of Flags.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Union{Tuple{R}, Tuple{T}, Tuple{QuantumFlag{T, R}, QuantumFlag{T, R}}} where {T<:Flag, R<:Real}","page":"Home","title":"Base.:-","text":":-(F::QuantumFlag{T,R}, G::QuantumFlag{T, R}) where {T <: Flag, R<:Real}\n\nSubtracts two linear combinations of Flags.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Union{Tuple{T}, Tuple{T, T}} where T<:Flag","page":"Home","title":"Base.:-","text":":-(F::T, G::T) where {T <: Flag}\n\nSubtracts two Flags. Returns a 'QuantumFlag{T, Int}'.\n\n\n\n\n\n","category":"method"},{"location":"#Base.one-Tuple{T} where T<:Flag","page":"Home","title":"Base.one","text":"one(F::T)::T where {T <: Flag}\n\nThe empty Flag of the same type as F.\n\n\n\n\n\n","category":"method"},{"location":"#Base.one-Union{Tuple{Type{T}}, Tuple{T}} where T<:Flag","page":"Home","title":"Base.one","text":"one(F::Type{T})::T where {T <: Flag}\n\nThe empty Flag of type T.\n\n\n\n\n\n","category":"method"},{"location":"#Base.size-Tuple{QuantumFlag}","page":"Home","title":"Base.size","text":"size(F::QuantumFlag)\n\nThe maximum size of the Flags in 'F'.\n\n\n\n\n\n","category":"method"},{"location":"#Base.size-Tuple{T} where T<:Flag","page":"Home","title":"Base.size","text":"size(F::T)::Int where {T<:Flag}\n\nThe size (number of vertices) of F.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.addLasserreBlock!-Union{Tuple{D}, Tuple{N}, Tuple{T}, Tuple{FlagModel{T, N, D}, Any}} where {T<:Flag, N, D}","page":"Home","title":"FlagSOS.addLasserreBlock!","text":"addLasserreBlock!(m::FlagModel{T,N,D}, maxEdges::Int; maxVertices = maxEdges * maxPredicateArguments(T)) where {T<:Flag,N,D}\n\nAdds a symmetry reduced Lasserre block of internal flag type 'T' to 'm' and returns it. All flags with up to 'floor(maxEdges/2)' edges (resp. true predicates) with optionally at most 'floor(maxVertices/2)' vertices are added as generators of the block. The resulting hierarchy contains flags with at most 'maxEdges' edges and 'maxVertices' vertices.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.addLasserreBlock!-Union{Tuple{FlagModel{T, N, D}}, Tuple{D}, Tuple{N}, Tuple{T}} where {T<:Flag, N, D}","page":"Home","title":"FlagSOS.addLasserreBlock!","text":"addLasserreBlock!(m::FlagModel{T,N,D}) where {T<:Flag,N,D}\n\nAdds an empty Lasserre block of internal flag type 'T' to 'm' and returns it. One should then use 'addFlag' to add generators to the block. \n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.addPredicates-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Vararg{U}}} where {T<:Flag, U<:FlagSOS.Predicate}","page":"Home","title":"FlagSOS.addPredicates","text":"addPredicates(::T, ::U, ::Vararg{U} where {T<:Flag,U<:Predicate}\n\nCreates a copy of F, and adds all predicates with the given values to the copy. May change the order of vertices of F, if necessary (E.g. in the case of PartiallyLabeledFlag). The predicates are given as a Vector of Vectors of Predicate-value pairs, sorted by type in a way that addPredicates understands.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.aut-Tuple{T} where T<:Flag","page":"Home","title":"FlagSOS.aut","text":"aut(F::T)::NamedTuple{(:gen, :size),Tuple{Vector{Vector{Int64}},Int64}} where {T<:Flag}\n\nThe automorphisms of F. Returns a named tuple with fields\n\ngen::Vector{Vector{Int}}: Vector of permutations generating all automorphisms.\nsize::Int: The size of the automorphism group of F.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.buildJuMPModel-Tuple{T} where T<:FlagSOS.AbstractFlagModel","page":"Home","title":"FlagSOS.buildJuMPModel","text":"Returns (Variables, Constraints)\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.countEdges-Tuple{QuantumFlag}","page":"Home","title":"FlagSOS.countEdges","text":"countEdges(F::QuantumFlag)\n\nThe maximum number of edges of the flags in 'F'.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.countEdges-Tuple{T} where T<:Flag","page":"Home","title":"FlagSOS.countEdges","text":"countEdges(F::T)::Vector{Int} where {T<:Flag}\n\nReturns the Vector of numbers of set predicates in the Flag F for each Predicate type. For Graphs, this is the Vector with one element, the number of edges in the graph. Used when generating all Flags up to isomorphism of a given type to specify an upper bound on the number of set predicates.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.distinguish-Union{Tuple{T}, Tuple{T, Int64, BitVector}} where T<:Flag","page":"Home","title":"FlagSOS.distinguish","text":"distinguish(F::T, v::Int, W::BitVector) where {T<:Flag}\n\nGiven a Flag F, a vertex v and a subset of vertices indicated by W, distinguish v by analyzing it's relationship to the vertices W. This may, for example, be the number of edges between v and the cell W, or the number of triangles with v and one/two vertices of W. The type of result does not matter, as it does get hashed after.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.findUnknownPredicates-Union{Tuple{U}, Tuple{T}, Tuple{T, Vector{U}}} where {T<:Flag, U<:AbstractVector{Int64}}","page":"Home","title":"FlagSOS.findUnknownPredicates","text":"findUnknownPredicates(F::T, fixed::Vector{Vector{Int}})\n\nGiven a Flag T, as well as subsets of vertices such that predicates (e.g. edges) are fixed if all arguments are within one of these sets. One should return a Predicate for each predicate and each combination of arguments, such that not all arguments are contained in one of the fixed subsets. The function returns a Vector of Vectors of Predicates, such that  should return a Vector of Vectors of Predicates addPredicates can understand it.\n\nThis is then used to determine the glued Flag in induced settings. For example, gluing the partially labelled edge 1-o to itself, would call\n\nfindUnknownPredicates(Graph(Bool[0 1 1; 1 0 0; 1 0 0]), [[1,2],[1,3]])\n\nThe only unclear predicate here is the edge [2,3], i.e. this function should return\n\n[[EdgePredicate(2,3)]]\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.generateAll-Union{Tuple{T}, Tuple{Type{T}, Int64, Vector{Int64}}} where T","page":"Home","title":"FlagSOS.generateAll","text":"generateAll(::Type{F}, maxVertices::Int, maxPredicates::Vector{Int}) where {F}\n\nGenerates all Flags of type F with up to maxVertices vertices and up to maxPredicates non-zero predicate values. 'maxPredicates' is a vector, for the case that there are multiple predicates.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.glue-Union{Tuple{T}, Tuple{InducedFlag{T}, InducedFlag{T}, AbstractVector{Int64}}} where T<:Flag","page":"Home","title":"FlagSOS.glue","text":"glue(F::InducedFlag{T}, G::InducedFlag{T}, p::Vector{Int})\n\nGlues together the two induced Flags F and G, after applying the permutation p to the vertices of F. p may be a permutation involving more than size(F) vertices. Since these Flags describe induced densities, the result is a linear combination of every possible combination of \"unknown\" edges between the added vertices from eachothers perspectives (or equivalent). If the common part is different, they are orthogonal to each other and thus return an empty Vector.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.glue-Union{Tuple{T}, Tuple{PartiallyLabeledFlag{T}, PartiallyLabeledFlag{T}, AbstractVector{Int64}}} where T<:Flag","page":"Home","title":"FlagSOS.glue","text":"glue(F::PartiallyLabeledFlag{T}, G::PartiallyLabeledFlag{T}, p::Vector{Int})\n\nGlues together the two partially labeled Flags F and G, after applying the permutation p to the vertices of F. p may be a permutation involving more than size(F) vertices, but should send the labeled part of F to the labeled part of G, without permuting indices there.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.glue-Union{Tuple{T}, Tuple{T, T, AbstractVector{Int64}}} where T<:Flag","page":"Home","title":"FlagSOS.glue","text":"glue(F::T, G::T, p::Vector{Int})::U where {T<:Flag, U<:Flag}\n\nGlues together the two Flags F and G, after applying the permutation p to the vertices of F. p may be a permutation involving more than size(F) vertices, in which case the result should have at least maximum(p) vertices. Optionally specifices a different output Flag type, for cases where the internal Flag type differs and there are performance advantages (such as the case of internal non-induced Graphs and the gluing of two induced Graphs).\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.glue-Union{Tuple{Vararg{T}}, Tuple{T}} where T<:Flag","page":"Home","title":"FlagSOS.glue","text":"glue(Fs::Vararg{T}) where {T<:Flag}\n\nGlues Flags together \"on top of each other\". Optionally specifices the output Flag type, for cases where a different type may improve performance (E.g. non-induced Flag as target for the gluing of two induced Flags). The default implementation only uses the custom type for the final gluing.\n\nglue(F, G, H)\n\nis equivalent to\n\nglue(F, glue(G, H, 1:size(G)), 1:size(F))\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.glueFinite-Union{Tuple{T}, Tuple{Any, T, T, AbstractVector{Int64}}} where T<:Flag","page":"Home","title":"FlagSOS.glueFinite","text":"glueFinite(N, F::T, G::T, p::AbstractVector{Int}; labelFlags = true) where {T<:Flag}\n\nGlues together the flags F and G, after applying the permutation p to the vertices of F. This variant of glue is for optimizing over finite objects, given by N which should be one of the options :limit, :variable or an integer. The operation assumes the k vertices that are sent on top of each other by p correspond to labels, and assumes that the other vertices are unlabeled, i.e. get sent to all N-k other vertices. \n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.isAllowed-Tuple{T} where T<:Flag","page":"Home","title":"FlagSOS.isAllowed","text":"isAllowed(F::T) where {T<:Flag}\n\nSometimes one may want to create a flag-algebra with inherently forbidden flags, instead of attaching it to a model. Then one should implement (or locally overwrite) this function.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.isAllowed-Union{Tuple{P}, Tuple{T}, Tuple{T, P}} where {T<:Flag, P<:FlagSOS.Predicate}","page":"Home","title":"FlagSOS.isAllowed","text":"isAllowed(F::T, e::P) where {T<:Flag, P<:Predicate}\n\nSometimes one may want to create a flag-algebra with inherently forbidden flags, instead of attaching it to a model. This function should return true iff the predicate P can be set to true (i.e. the edge P can be added).\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.isIsomorphic-Union{Tuple{T}, Tuple{T, T}} where T<:Flag","page":"Home","title":"FlagSOS.isIsomorphic","text":"isIsomorphic(F::T, G::T) where {T<:Flag}\n\nChecks if two flags are isomorphic.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.isSubFlag-Union{Tuple{T}, Tuple{T, T}} where T<:Flag","page":"Home","title":"FlagSOS.isSubFlag","text":"isSubFlag(F::T, G::T) where {T<:Flag}\n\nChecks if 'F' appears as sub-flag of 'G'.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.isSym-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T<:Flag","page":"Home","title":"FlagSOS.isSym","text":"isSym(F::T, v1::Int, v2::Int)::Bool where {T<:Flag}\n\nReturns true if the permutation which swaps the vertices v1 and v2 is an automorphism of F.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.isVariableVertex-Union{Tuple{T}, Tuple{T, Int64}} where T<:Flag","page":"Home","title":"FlagSOS.isVariableVertex","text":"isVariableVertex(F::T, v::Int) where {T<:Flag}\n\nReturns true if vertex v is one of the \"variable vertices\", i.e. vertices of which the number goes towards infinity. Per default, it always returns true. But, for example, for partially labeled Flags, it only returns true if the vertex is unlabeled.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.isolatedVertices-Tuple{PartiallyLabeledFlag}","page":"Home","title":"FlagSOS.isolatedVertices","text":"isolatedVertices(F::PartiallyLabeledFlag)::BitVector\n\nReturns the isolated, and un-labeled vertices of F.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.isolatedVertices-Tuple{T} where T<:Flag","page":"Home","title":"FlagSOS.isolatedVertices","text":"isolatedVertices(F::T)::Vector{Int} where{T<:Flag}\n\nReturns the indicator vector of isolated vertices of F.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.labelCanonically-Tuple{T} where T<:Flag","page":"Home","title":"FlagSOS.labelCanonically","text":"labelCanonically(F::T)::T where {T <: Flag}\n\nLabels F canonically. If two Flags are isomorphic, this function should return the same Flag.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.labelCanonically-Union{Tuple{QuantumFlag{T, R}}, Tuple{R}, Tuple{T}} where {T<:Flag, R<:Real}","page":"Home","title":"FlagSOS.labelCanonically","text":"labelCanonically(F::QuantumFlag{T,R})::QuantumFlag{T,R} where {T <: Flag, R <: Real}\n\nLabels F canonically. If two Flags are isomorphic, this function should return the same Flag.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.labelCanonically-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Flag","page":"Home","title":"FlagSOS.labelCanonically","text":"labelCanonically(Fs::Vector{T})::Vector{T} where {T <: Flag}\n\nLabels all Flags in Fs canonically. If two Flags are isomorphic, this function should return the same Flag.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.maxPredicateArguments-Union{Tuple{Type{T}}, Tuple{T}} where T<:Flag","page":"Home","title":"FlagSOS.maxPredicateArguments","text":"maxPredicateArguments(::Type{T}) where {T<:Flag}\n\nMaximum number of arguments of a predicate in the theory 'T'. For instance, this is '2' for graphs, as the only predicate, the edge predicate, takes two arguments.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.moebius-Union{Tuple{FlagSOS.EdgeMarkedFlag{T}}, Tuple{T}} where T<:Flag","page":"Home","title":"FlagSOS.moebius","text":"moebius(F::EdgeMarkedFlag{T}) where {T<:Flag}\n\nComputes the moebius transform of an edge-marked flag on the marked edges. \n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.moebius-Union{Tuple{T}, Tuple{T, Any}} where T<:Flag","page":"Home","title":"FlagSOS.moebius","text":"moebius(F::T, verts = 1:size(F)) where {T<:Flag}\n\nComputes the moebius transform of a flag on the vertices 'verts'\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.overlaps","page":"Home","title":"FlagSOS.overlaps","text":"overlaps(lambda, mu [, total = pN, limit::Bool = false, fixedN = false])\n\nCalculate the different ways two partitions can overlap, with multiplicities. Lambda is considered fixed, mu changes. Adds a biggest dynamic part by (lambda,n-sum(lambda)). Result is array of pairs, first is multiplicity depending on n, second is matrix. Rows are lambda i (last is dynamic sized), columns are mu i (last is dynamic sized)\n\nTo get the total amount of combinations (i.e. lambda can move around, too), multiply all multiplicities with numSplits(lambda). We have overlaps(lambda,mu) * numsplits(lambda) == overlaps(mu,lambda) * numSplits(mu).\n\nExamples\n\njulia> overlaps([1],[2])\n2-element Array{Any,1}:\n (1//2*n^2-3//2*n+1//1, [0 2; 1 0])\n (n-1//1, [1 1; 0 0])\n\nCorresponds to the two ways the partitions (1,n-1) and (2,n-2) can overlap. The first element is the overlap, where the 2-part of mu lies in the n-1 part of lambda, with multiplicity n-1 choose 2. The second is the one where 1 element of the 2-part of mu lies in the 1-part of lambda, with multiplicity n-1 choose 1.\n\n\n\n\n\n","category":"function"},{"location":"#FlagSOS.permute-Union{Tuple{T}, Tuple{T, AbstractVector{Int64}}} where T<:Flag","page":"Home","title":"FlagSOS.permute","text":"permute(F::T, p::AbstractVector{Int})::T where {T<:Flag}\n\nPermutes the vertices of F according to the permutation p.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.possibleValues-Union{Tuple{Type{P}}, Tuple{P}} where P<:FlagSOS.Predicate","page":"Home","title":"FlagSOS.possibleValues","text":"possibleValues(::Type{P}) where {P<:Predicate}\n\nReturns the possible non-zero (!) values of a predicate of type P. Usually just [true], but for example directed graphs (without possiblity of a bi-directional edge) may have predicate values 0, 1 and -1.\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.subFlag-Union{Tuple{T}, Tuple{T, AbstractVector{Int64}}} where T<:Flag","page":"Home","title":"FlagSOS.subFlag","text":"subFlag(F::T, vertices::AbstractVector{Int})::T where {T<:Flag}\n\nReturns the sub-Flag indexed by vertices, which is a subset of 1:size(F).\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.subFlag-Union{Tuple{T}, Tuple{T, BitVector}} where T<:Flag","page":"Home","title":"FlagSOS.subFlag","text":"subFlag(F::T, vertices::BitVector)::T where {T<:Flag}\n\nReturns the sub-Flag given by the indicator vector vertices, which is a BitVector of length size(F). If not extended, it calls subFlag(F, findall(vertices)).\n\n\n\n\n\n","category":"method"},{"location":"#FlagSOS.vertexColor-Union{Tuple{T}, Tuple{T, Int64}} where T<:Flag","page":"Home","title":"FlagSOS.vertexColor","text":"vertexColor(::T, ::Int) where {T<:Flag}\n\nReturns the color of vertices in colored Flags. The default is the case of a vertex-transitive Flags-type, where all vertices have color 1.\n\n\n\n\n\n","category":"method"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"EditURL = \"CaccettaHaeggkvist.jl\"","category":"page"},{"location":"examples/CaccettaHaeggkvist/#Constrained-example:-Caccetta-Haeggkvist-conjecture","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"","category":"section"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"The maximum minimum outdegree of a directed graph (without digons) without directed triangles is conjectured to be frac13:","category":"page"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"beginaligned\nfrac13=max_G text directed graph r\ntextstenspace  G text has no directed triangles\n textthe relative outdegree of every vertex is at least r\nendaligned","category":"page"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"Here we compute an upper bound using a basic application of flag algebras. A more advanced application of the method lead to current best bound.","category":"page"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"using FlagSOS","category":"page"},{"location":"examples/CaccettaHaeggkvist/#Setting-up-the-model","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Setting up the model","text":"","category":"section"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"We work with directed graphs without digons.","category":"page"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"const Digraph = DirectedGraph{false}","category":"page"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"We define the relevant graphs using their adjacency matrices.","category":"page"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"directedEdge = Digraph(Bool[0 1; 0 0]);\ndirectedTriangle = Digraph(Bool[0 1 0; 0 0 1; 1 0 0]);\nnothing #hide","category":"page"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"We start with an empty FlagModel of type DirectedGraph, where we forbid the directed triangle:","category":"page"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"m = FlagModel{Digraph}()\naddForbiddenFlag(m, directedTriangle)","category":"page"},{"location":"examples/CaccettaHaeggkvist/#Choosing-a-relaxation","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Choosing a relaxation","text":"","category":"section"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"Now we need to choose a hierarchy. One option is the Lasserre hierarchy, which we can attach to the model using addLasserreBlock!.","category":"page"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"addLasserreBlock!(m, 4);\nnothing #hide","category":"page"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"This results in a semidefinite programming problem with block sizes","category":"page"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"modelSize(m)","category":"page"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"We want to maximize the directedEdge density, which we can do by minimizing its negative","category":"page"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"m.objective = -1 * directedEdge\n\nconst lDigraph = PartiallyLabeledFlag{Digraph}\n\ne1 = lDigraph(Bool[0 1; 0 0]; n=1)\ne2 = lDigraph(Bool[0 0; 1 0]; n=1)\neL = lDigraph(Bool[0 1; 0 0]; n=0)\n\nqm2 = FlagSOS.addEquality(m, e1 - eL, 4);\nnothing #hide","category":"page"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"Finally, we compute the coefficients of the SDP.","category":"page"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"computeSDP!(m)","category":"page"},{"location":"examples/CaccettaHaeggkvist/#Solving-the-SDP","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Solving the SDP","text":"","category":"section"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"We solve the relaxation using Hypatia.","category":"page"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"using Hypatia, JuMP\njm = buildJuMPModel(m)\nset_optimizer(jm.model, Hypatia.Optimizer)\noptimize!(jm.model)\ntermination_status(jm.model)","category":"page"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"objective_value(jm.model)","category":"page"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"","category":"page"},{"location":"examples/CaccettaHaeggkvist/","page":"Constrained example: Caccetta Haeggkvist conjecture","title":"Constrained example: Caccetta Haeggkvist conjecture","text":"This page was generated using Literate.jl.","category":"page"}]
}
